#include <iostream> // 引入输入输出流库，用于控制台输入输出
#include <vector>   // 引入向量库，用于存储动态数组
#include <queue>    // 引入队列库，用于广度优先搜索（BFS）
#include <string>   // 引入字符串库，用于处理每一行的地图数据

using namespace std; // 使用标准命名空间，避免每次调用标准库时加std::前缀

// 定义结构体Point，用于存储网格中的坐标点
struct Point { // 开始定义Point结构体
    int x;     // 存储行坐标
    int y;     // 存储列坐标
}; // Point结构体定义结束

int main() { // 主函数入口
    int n, m; // 定义两个整型变量n和m，分别代表网格的行数和列数
    if (!(cin >> n >> m)) return 0; // 从标准输入读取n和m，如果读取失败则直接返回

    int xs, ys, xt, yt; // 定义四个整型变量，分别代表起点和终点的坐标
    cin >> xs >> ys >> xt >> yt; // 从标准输入读取起点的(x, y)和终点的(x, y)

    // 题目输入的坐标是基于1的（1到n，1到m），我们需要转换为基于0的索引以便于数组访问
    xs--; // 将起点行坐标减1
    ys--; // 将起点列坐标减1
    xt--; // 将终点行坐标减1
    yt--; // 将终点列坐标减1

    vector<string> grid(n); // 定义一个字符串向量grid，大小为n，用于存储地图的每一行
    for (int i = 0; i < n; ++i) { // 循环n次，读取每一行地图数据
        cin >> grid[i]; // 读取第i行的字符串，'.'表示通路，'*'表示障碍
    } // 读取地图数据的循环结束

    // 定义两个数组dx和dy，分别表示在x和y方向上的移动偏移量
    // 顺序对应：上(-1,0)，下(1,0)，左(0,-1)，右(0,1)
    int dx[] = {-1, 1, 0, 0}; // x方向的偏移量数组
    int dy[] = {0, 0, -1, 1}; // y方向的偏移量数组

    // 定义一个二维向量dist，用于存储起点到每个点的最短步数
    // 初始化为-1，表示该点尚未被访问过
    vector<vector<int>> dist(n, vector<int>(m, -1)); // 创建n行m列的二维数组，初始值全为-1

    queue<Point> q; // 定义一个队列q，用于存放待访问的坐标点，实现BFS
    q.push({xs, ys}); // 将起点加入队列
    dist[xs][ys] = 0; // 起点到自己的距离为0

    // 开始广度优先搜索（BFS）
    while (!q.empty()) { // 当队列不为空时，继续循环
        Point curr = q.front(); // 获取队首元素作为当前处理的点
        q.pop(); // 将队首元素移出队列

        // 检查当前点是否为终点
        if (curr.x == xt && curr.y == yt) { // 如果当前坐标等于终点坐标
            cout << dist[curr.x][curr.y] << endl; // 输出从起点到当前点的距离
            return 0; // 找到终点，程序成功结束
        } // 终点判断结束

        // 尝试向四个方向移动
        for (int i = 0; i < 4; ++i) { // 遍历四个可能的移动方向
            int nx = curr.x + dx[i]; // 计算移动后的新行坐标
            int ny = curr.y + dy[i]; // 计算移动后的新列坐标

            // 检查新坐标是否在网格范围内
            if (nx >= 0 && nx < n && ny >= 0 && ny < m) { // 确保nx在[0, n-1]且ny在[0, m-1]范围内
                // 检查新坐标是否可以通行且未被访问过
                if (grid[nx][ny] == '.' && dist[nx][ny] == -1) { // 如果是'.'且dist为-1
                    dist[nx][ny] = dist[curr.x][curr.y] + 1; // 更新新点的距离为当前点距离加1
                    q.push({nx, ny}); // 将新点加入队列，以便后续探索其邻居
                } // 可通行且未访问判断结束
            } // 边界检查结束
        } // 四个方向遍历结束
    } // BFS循环结束

    // 如果队列为空且仍未找到终点（即无法到达终点）
    cout << -1 << endl; // 输出-1表示无法从起点到达终点

    return 0; // 主函数结束
} // 程序结束
