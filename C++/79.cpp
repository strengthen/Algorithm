#include <iostream> // 引入输入输出流库，用于控制台输入输出
#include <vector>   // 引入向量库，用于存储动态数组
#include <string>   // 引入字符串库，用于处理字符串
#include <algorithm> // 引入算法库，用于使用排序函数

using namespace std; // 使用标准命名空间，避免每次调用标准库需加std::前缀

int main() { // 主函数入口
    int n; // 定义整型变量n，表示物品的总数量
    long long k; // 定义长整型变量k，表示支付宝余额（防止计算过程溢出）
    
    // 读取n和k的值，作为输入的开始
    if (cin >> n >> k) { 
        vector<long long> a(n); // 创建一个大小为n的长整型向量a，用于存储每个物品的原价
        for (int i = 0; i < n; i++) { // 循环n次，读取每个物品的价格
            cin >> a[i]; // 从输入流读取第i个物品的价格并存入向量a中
        }

        string s; // 定义字符串变量s，用于存储每个物品是否支持优惠的标识
        cin >> s; // 读取由'0'和'1'组成的字符串

        vector<long long> costs(n); // 创建一个大小为n的长整型向量costs，存储每个物品的实际代价
        // 为了避免浮点数运算的精度问题，我们将所有金额放大20倍进行计算
        // 原价 * 0.95 等价于 (原价 * 19) / 20
        // 比较时：代价 <= 余额，两边同乘20，即 代价*20 <= 余额*20
        
        for (int i = 0; i < n; i++) { // 遍历每一个物品，计算其购买代价
            if (s[i] == '1') { // 如果字符串第i位是'1'，表示该物品支持九五折优惠
                costs[i] = a[i] * 19; // 计算优惠后的相对代价：原价 * 19 (即原价 * 0.95 * 20)
            } else { // 如果字符串第i位是'0'，表示该物品不支持优惠
                costs[i] = a[i] * 20; // 计算无优惠的相对代价：原价 * 20
            }
        }

        sort(costs.begin(), costs.end()); // 对所有物品的实际代价进行升序排序，以便优先购买便宜的

        long long total_budget = k * 20; // 将总余额也放大20倍，以便与代价进行比较
        int count = 0; // 定义计数器count，用于记录购买的物品数量，初始化为0

        for (int i = 0; i < n; i++) { // 遍历排序后的物品代价列表
            if (total_budget >= costs[i]) { // 如果当前的放大后预算足以支付当前物品的放大后代价
                total_budget -= costs[i]; // 从预算中扣除该物品的代价
                count++; // 成功购买，计数器加1
            } else { // 如果预算不足以支付当前最便宜的物品
                break; // 停止购买，跳出循环
            }
        }

        cout << count << endl; // 输出最终能购买的最大物品数量
    }

    return 0; // 程序正常结束，返回0
}
