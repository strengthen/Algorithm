#include <iostream> // 引入输入输出流库，用于控制台输入输出

using namespace std; // 使用标准命名空间，避免每次调用标准库函数时都需要加std::前缀

// 定义一个递归函数 countWays 来计算放苹果的方法数
// 参数 m 表示剩余的苹果数量
// 参数 n 表示可用的盘子数量
int countWays(int m, int n) {
    // 递归基准情况1：如果苹果数量 m 为 0，表示没有苹果了，这算作一种分法（所有盘子为空或已放好）
    // 递归基准情况2：如果盘子数量 n 为 1，所有苹果只能都放在这一个盘子里，也只有一种分法
    if (m == 0 || n == 1) {
        return 1; // 返回1表示这是一种有效的情况
    }

    // 特殊情况：如果盘子数量 n 大于苹果数量 m
    // 因为盘子是相同的，多出来的 n-m 个盘子必然是空的
    // 所以这种情况等价于将 m 个苹果放入 m 个盘子中
    if (n > m) {
        return countWays(m, m); // 递归调用，将盘子数缩减为苹果数
    }

    // 一般情况：苹果数量 m 大于等于盘子数量 n
    // 这时可以将分法分为两类互斥的情况：
    // 1. 至少有一个盘子是空的：这相当于把 m 个苹果放入 n-1 个盘子中，即 countWays(m, n - 1)
    // 2. 所有盘子都不空：先在每个盘子放 1 个苹果（消耗 n 个苹果），剩下的 m-n 个苹果再放入 n 个盘子中，即 countWays(m - n, n)
    return countWays(m, n - 1) + countWays(m - n, n); // 返回这两种情况的方法数之和
}

int main() { // 主函数，程序的入口点
    int m, n; // 定义两个整型变量，m 代表苹果数，n 代表盘子数

    // 使用 while 循环从标准输入读取数据
    // cin >> m >> n 会尝试读取两个整数，如果读取成功则继续循环，适合多组输入
    while (cin >> m >> n) {
        // 调用 countWays 函数计算 m 个苹果放入 n 个盘子的不同分法数量
        // 并将结果输出到控制台，随后换行
        cout << countWays(m, n) << endl;
    }

    return 0; // 程序正常执行完毕，返回 0
}
