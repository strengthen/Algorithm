#include <iostream> // 引入输入输出流库，用于控制台输入输出
#include <string>   // 引入字符串库，用于处理字符串s
#include <vector>   // 引入向量库，虽然本题主要用string，但作为常用库引入无妨

using namespace std; // 使用标准命名空间std，避免每次调用标准库都要加std::

int main() { // 主函数入口
    // 优化输入输出效率，取消cin与stdin的同步，提高大数据量下的读写速度
    ios::sync_with_stdio(false); 
    // 解除cin与cout的绑定，避免每次输入前强制刷新输出缓冲区
    cin.tie(nullptr); 

    long long n, k; // 定义变量n和k，n为字符串长度，k为目标"01"子序列数量，使用long long防止k溢出（k最大10^10）
    if (!(cin >> n >> k)) return 0; // 从标准输入读取n和k，如果读取失败则退出程序

    string s; // 定义字符串变量s，用于存储输入的01串
    cin >> s; // 从标准输入读取字符串s

    long long current_k = 0; // 用于记录当前滑动窗口[l, r]内"01"子序列的总数量
    long long cnt0 = 0; // 用于记录当前滑动窗口内字符'0'的个数
    long long cnt1 = 0; // 用于记录当前滑动窗口内字符'1'的个数
    int l = 0; // 定义滑动窗口的左端点l，初始化为0（对应题目下标1）

    // 使用for循环，让右指针r从0遍历到n-1，不断扩大窗口
    for (int r = 0; r < n; ++r) {
        // 判断当前右指针指向的字符是'0'还是'1'
        if (s[r] == '0') { 
            cnt0++; // 如果是'0'，则窗口内'0'的计数加1
        } else { // 如果是'1'
            cnt1++; // 窗口内'1'的计数加1
            // 新加入的'1'可以和它左边所有的'0'分别构成一个"01"子序列
            // 所以当前窗口内的"01"子序列总数增加cnt0个
            current_k += cnt0; 
        }

        // 检查当前窗口内的"01"子序列数量是否超过了目标值k
        // 如果超过了k，或者窗口不合法（理论上l<=r在循环中自然满足，但作为保护条件），则收缩左边界
        while (current_k > k && l <= r) {
            // 判断左指针指向的字符是'0'还是'1'，准备将其移出窗口
            if (s[l] == '0') {
                cnt0--; // 如果移出的是'0'，则窗口内'0'的计数减1
                // 这个'0'被移出后，它和当前窗口内所有的'1'构成的"01"子序列都消失了
                // 所以总数减少cnt1个（注意此时cnt1包含刚才新加入的'1'，逻辑是正确的）
                current_k -= cnt1; 
            } else {
                cnt1--; // 如果移出的是'1'，则窗口内'1'的计数减1
                // 移出一个'1'，因为它在最左侧，前面没有'0'能和它构成"01"，所以current_k不变
            }
            l++; // 左指针向右移动一位，完成收缩
        }

        // 每次调整完窗口（扩大右边，收缩左边）后，检查是否恰好满足条件
        if (current_k == k) {
            // 如果满足条件，输出当前的左右端点
            // 题目要求下标从1开始，所以输出 l+1 和 r+1
            cout << l + 1 << " " << r + 1 << endl;
            return 0; // 找到任意一个满足条件的区间即可，直接结束程序
        }
    }

    // 如果循环结束还没有找到满足条件的区间，说明不存在这样的区间
    cout << -1 << endl; // 输出-1

    return 0; // 程序正常结束
}
