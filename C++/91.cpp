#include <iostream> // 引入输入输出流库

using namespace std; // 使用标准命名空间

// 定义递归函数 solve，用于计算从 (0,0) 到达 (n,m) 的路径方案数
// 参数 n 表示剩余需要向下移动的步数（或者说是剩余的行数）
// 参数 m 表示剩余需要向右移动的步数（或者说是剩余的列数）
int solve(int n, int m) {
    // 递归终止条件：如果 n 为 0，说明已经到达最底行，只能向右一直走，只有 1 种方案
    if (n == 0) return 1;
    // 递归终止条件：如果 m 为 0，说明已经到达最右列，只能向下一直走，只有 1 种方案
    if (m == 0) return 1;
    
    // 递归步骤：当前的方案数等于“向下走一步后的方案数”加上“向右走一步后的方案数”
    // solve(n - 1, m) 代表向下走一步，剩下的网格变为 (n-1) 行 m 列
    // solve(n, m - 1) 代表向右走一步，剩下的网格变为 n 行 (m-1) 列
    return solve(n - 1, m) + solve(n, m - 1);
}

// 主函数
int main() {
    int n, m; // 定义两个整型变量 n 和 m，分别代表网格的行数和列数

    // 使用 while 循环读取输入，支持多组测试数据
    // cin >> n >> m 会从标准输入读取两个整数，如果读取失败（如文件结束）循环终止
    while (cin >> n >> m) {
        // 调用 solve 函数计算 n 行 m 列网格从左上角到右下角的路径方案数
        // 并将结果输出到标准输出，最后换行
        cout << solve(n, m) << endl;
    }

    return 0; // 程序正常结束，返回 0
}
