#include <iostream> // 引入输入输出流库，用于控制台输入输出
#include <vector> // 引入向量容器库，用于存储动态数组
#include <deque> // 引入双端队列容器库，用于实现单调队列

using namespace std; // 使用标准命名空间，避免每次调用标准库时加std::前缀

int main() { // 主函数入口
    ios::sync_with_stdio(false); // 关闭C++标准流与C标准IO库的同步，提高输入输出效率
    cin.tie(0); // 解除cin与cout的绑定，防止每次输入前自动刷新输出缓冲区，提高效率

    int n, k; // 声明两个整型变量n和k，分别表示数组长度和滑动窗口大小
    if (cin >> n >> k) { // 从标准输入读取n和k的值，并判断读取是否成功
        vector<int> a(n); // 创建一个大小为n的整型向量a，用于存储输入的数组元素
        for (int i = 0; i < n; ++i) { // 循环遍历，从索引0到n-1
            cin >> a[i]; // 从标准输入读取第i个元素的值并存入向量a中
        } // 循环结束

        deque<int> dq; // 创建一个双端队列dq，用于存储数组元素的下标，维护单调递减性质
        for (int i = 0; i < n; ++i) { // 遍历数组中的每一个元素，索引为i
            // 检查队首元素是否已经滑出当前窗口范围
            if (!dq.empty() && dq.front() == i - k) { // 如果队列不为空且队首下标等于i-k（即不在[i-k+1, i]范围内）
                dq.pop_front(); // 将队首元素移除，因为它已经不在当前滑动窗口内
            } // 条件判断结束

            // 维护队列的单调递减性，确保队首始终是当前窗口最大值的下标
            while (!dq.empty() && a[dq.back()] <= a[i]) { // 当队列不为空且队尾元素对应的数值小于等于当前元素a[i]时
                dq.pop_back(); // 移除队尾元素，因为a[i]更大且更晚出现，队尾元素不可能再成为最大值
            } // 循环结束

            dq.push_back(i); // 将当前元素的下标i加入队尾

            // 当遍历过的元素个数达到窗口大小时，开始输出结果
            if (i >= k - 1) { // 如果当前索引i大于等于k-1，说明已经形成了一个完整的窗口
                cout << a[dq.front()] << (i == n - 1 ? "" : " "); // 输出当前窗口的最大值（队首元素对应的数值），最后一个元素后不加空格，否则加空格
            } // 条件判断结束
        } // 循环结束
        cout << endl; // 所有结果输出完毕后，输出一个换行符
    } // if语句结束
    return 0; // 主函数返回0，表示程序正常结束
} // 主函数结束
