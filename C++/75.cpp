#include <iostream> // 引入输入输出流库，用于控制台输入输出
#include <string>   // 引入字符串库，用于处理字符串操作
#include <vector>   // 引入向量库，用于创建动态数组（虽然本题可以用静态数组，但vector更通用）
#include <algorithm> // 引入算法库，用于使用max函数

using namespace std; // 使用标准命名空间

int main() { // 主函数
    string s1, s2; // 定义两个字符串变量，分别存储输入的两个字符串
    
    // 读取两个字符串。题目保证仅由小写字母组成，且长度较短（<=150）
    // 使用 cin 读取即可，它会跳过空白字符
    if (cin >> s1 >> s2) { 
        int n = s1.length(); // 获取第一个字符串的长度
        int m = s2.length(); // 获取第二个字符串的长度
        
        // 定义一个二维动态数组 dp，大小为 (n+1) x (m+1)，并初始化所有元素为 0
        // dp[i][j] 表示以 s1[i-1] 和 s2[j-1] 结尾的最长公共子串的长度
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        
        int maxLen = 0; // 用于记录遍历过程中发现的最长公共子串的长度，初始化为 0
        
        // 遍历第一个字符串的每个字符 (下标从 1 到 n)
        for (int i = 1; i <= n; ++i) {
            // 遍历第二个字符串的每个字符 (下标从 1 到 m)
            for (int j = 1; j <= m; ++j) {
                // 如果 s1 的第 i 个字符和 s2 的第 j 个字符相等
                // 注意：字符串下标是从 0 开始的，所以这里用 i-1 和 j-1
                if (s1[i - 1] == s2[j - 1]) {
                    // 当前位置的最长公共子串长度等于左上角位置的长度加 1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    
                    // 更新最大长度
                    if (dp[i][j] > maxLen) {
                        maxLen = dp[i][j];
                    }
                } else {
                    // 如果字符不相等，说明以这两个字符结尾的公共子串长度为 0
                    // 由于初始化为 0，这步其实可以省略，为了清晰加上
                    dp[i][j] = 0;
                }
            }
        }
        
        // 输出最长公共子串的长度
        cout << maxLen << endl;
    }
    
    return 0; // 程序正常结束
}
